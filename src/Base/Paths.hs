{-# language ScopedTypeVariables #-}

-- This is a replacment for cabal's autogenerated Paths_nikki.hs
-- Use this instead to find data files.
-- Needed for deployment in one folder

module Base.Paths (
    getDataFileName,
    getDataFiles,
    getConfigurationDirectory,
    getConfigurationFile,
    withStaticConfiguration,
    withDynamicConfiguration,

    -- * story mode data
    getStoryModeDataFileName,
    getStoryModeDataFiles,
  ) where


import Safe

import Data.List
import Data.Initial

import Text.Logging

import Control.Monad.Reader
import Control.Monad.State.Strict
import Control.Monad.CatchState
import Control.Monad.CatchIO

import System.Info
import System.FilePath
import System.Directory
import System.Environment
import System.Environment.FindBin
import System.Console.CmdArgs as CmdArgs

import Utils

import Base.Types
import Base.Configuration


getDataFileName :: FilePath -> RM FilePath
getDataFileName p = do
    inPlace <- asks run_in_place
    if inPlace then
        return (".." </> "data" </> p)
      else do
        progPath <- io getProgPath
        case os of
            "linux" ->
                return (progPath </> "data" </> p)
            "mingw32" ->
                -- works if the application is deployed in one folder
                return (progPath </> "data" </> p)
            "darwin" ->
                -- works if the application is bundled in an app
                return (progPath </> ".." </> "Resources" </> p)
            x -> error ("unsupported os: " ++ os)

-- | returns unhidden files with a given extension in a given data directory.
getDataFiles :: FilePath -> (Maybe String) -> RM [FilePath]
getDataFiles path_ extension = do
    path <- getDataFileName path_
    map (path </>) <$> io (getFiles path extension)


-- * configuration

-- | returns the user's configuration directory
getConfigurationDirectory :: IO FilePath
getConfigurationDirectory = do
    d <- getAppUserDataDirectory "nikki"
    createDirectoryIfMissing True d
    return d

-- | Returns the path to the configuration file.
-- The file might be non-existent.
getConfigurationFile :: IO FilePath
getConfigurationFile = do
    d <- getConfigurationDirectory
    return (d </> "configuration")

-- | loads the configuration and initialises the logging command.
-- (before calling loadConfiguration, nothing should be logged.)
loadConfiguration :: IO Configuration
loadConfiguration = do
    filteredArgs <- filterUnwantedArgs <$> getArgs
    mLoadedSavedConfig <- loadConfigurationFromFile
    let loadedSavedConfig = case mLoadedSavedConfig of
            Left (logLevel, msg) -> initial
            Right x -> x
        loadedConfig = savedConfigurationToConfiguration loadedSavedConfig
    config <- withArgs filteredArgs $ cmdArgs loadedConfig
    case mLoadedSavedConfig of
        -- retain error messages till after execution of cmdArgs 
        -- to prevent pollution of version or help output
        Left (logLevel, msg) -> logg logLevel msg
        _ -> return ()
    return config

-- | on OS X there is a default command line argument
-- (-psn_SOMETHING_WITH_THE_PID) passed to the application
-- when launched in application bundle mode.
-- We remove this from the arguments before processing via CmdArgs.
filterUnwantedArgs :: [String] -> [String]
filterUnwantedArgs = case System.Info.os of
    "darwin" -> filter (\ arg -> not ("-psn_" `isPrefixOf` arg))
    _ -> id

-- | loads the configuration from file.
-- If the file does not exists, it is initialized with the default configuration.
-- Also returns a message, if necessary.
loadConfigurationFromFile :: IO (Either (LogLevel, String) SavedConfiguration)
loadConfigurationFromFile = do
    file <- getConfigurationFile
    exists <- doesFileExist file
    if (not exists) then
        -- no config file found
        return $ Left (Info, "no configuration file found, using default configuration.")
      else do
        -- attempting to load configuration
        mLoaded :: Maybe SavedConfiguration <- readMay <$> readFile file
        case mLoaded of
            Nothing ->
                return $ Left (Error, "unable to read configuration file, using default configuration")
            Just config -> return $ Right config

saveConfigurationToFile :: SavedConfiguration -> IO ()
saveConfigurationToFile config = do
    file <- getConfigurationFile
    writeFile file (show config)

-- | reads the configuration
-- configuration should not be changed
withStaticConfiguration :: ConfigurationReader a -> IO a
withStaticConfiguration action =
    runReaderT action =<< loadConfiguration

-- | Executes an M Monad.
-- Will save changes to the configuration afterwards
-- (Once this is possible, for now M is just ReaderT Configuration IO)
withDynamicConfiguration :: Configuration -> M a -> IO a
withDynamicConfiguration configuration action =
    fst <$> runCatchState (action `finally` save) configuration
  where
    save =
        (io . saveConfigurationToFile . configurationToSavedConfiguration) =<< get


-- * Story mode data

getStoryModeDataFileName :: FilePath -> IO (Maybe FilePath)
getStoryModeDataFileName path = do
    dir <- getAppUserDataDirectory "nikki-story-mode"
    let file = dir </> "data" </> path
    fileExists <- doesFileExist file
    dirExists <- doesDirectoryExist file
    if (fileExists || dirExists)
        then return $ Just file
        else do
            logg Debug ("sm-file not found: " ++ path)
            return Nothing

getStoryModeDataFiles :: FilePath -> (Maybe String) -> IO (Maybe [FilePath])
getStoryModeDataFiles path_ extension = do
    mPath <- getStoryModeDataFileName path_
    case mPath of
        Nothing -> return Nothing
        Just path -> Just <$> map (path </>) <$> io (getFiles path extension)
